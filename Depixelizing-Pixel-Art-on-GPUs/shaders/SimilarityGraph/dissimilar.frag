#version 330 core

// Copyright (c) 2015 Felix Kreuzer
//
// This source is subject to the MIT License.
// Please see the LICENSE.txt file for more information.
// All other rights reserved.
//
// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.

/** 
 * @file dissimilar.frag
 * This fragment shader computes an initial version of the Similarity Graph.
 * The garph is generated by compairing each source pixels' 3x3 neighbourhood.
 * Once a similar coloured neighbor is found it an edge indicator will be written to the output fragment.
 * This way we can represent pixel connectivity.
 * This shader is supposed to run once per putput fragment.
 * The similarity graph datastructure will follow this schematic:
 * <BR>
 * E E E E E
 * <BR>
 * E X E X E
 * <BR>
 * E E E E E
 * <BR>
 * E X E X E
 * <BR>
 * E E E E E
 * <BR>
 * with Edge indicators E and pixel-nodes X.
 */
 


#define EDGE_HORVERT 16 /**< this macro represents a horizontal or vertical edge connecting two adjacent pixels.*/

#define EDGE_DIAGONAL_ULLR 32 /**< this macro represents a diagonal edge connecting two diagonally adjacent pixels.*/

#define EDGE_DIAGONAL_LLUR 64 /**< this macro represents a diagonal edge connecting two diagonally adjacent pixels.*/

#define EDGE_CROSSING 96 /**< this macro represents two edges connecting four diagonally adjacent pixels.*/

in vec2 UV; /**< UV coordinate of the current pixel. */

layout(pixel_center_integer) in vec4 gl_FragCoord; /**< absolute viewport coordinate of the current pixel. */
uniform sampler2D pixelArt; /**< texture containing the source image. */


layout(location = 0) out vec4 color0; /**< output pixel.*/

/**
* @fn ivec2 getPixelCoords(ivec2 graphCoords)
* used to fetch a pixel from the source texture.
* @param graphCoords similarity graph pixel coordinates
* @return source image pixel coordinates
*/
ivec2 getPixelCoords(ivec2 graphCoords) {
	
	return (graphCoords-1)/2;
}

/**
* @fn bool isSimilar(vec4 pixelA, vec4 pixelB)
* checks wheather two colors are similar or not.
* @param pixelA first pixel color
* @param pixelB second pixel color
* @return TRUE if the colors are considered to be similar
*/
bool isSimilar(vec4 pixelA, vec4 pixelB) {
	//Y = 0.299*R + 0.587*G + 0.114*B
	//U = (B-Y)*0.493
	//V = (R-Y)*0.877
	float yA = 0.299*pixelA.r + 0.587*pixelA.g + 0.114*pixelA.b;
	float uA = 0.493*(pixelA.b-yA);
	float vA = 0.877*(pixelA.r-yA);
	float yB = 0.299*pixelB.r + 0.587*pixelB.g + 0.114*pixelB.b;
	float uB = 0.493*(pixelB.b-yB);
	float vB = 0.877*(pixelB.r-yB);
	
	bool similar = false;
	if( abs(yA-yB) <= 48.0/255.0) {
		if( abs(uA-uB) <= 7.0/255.0) {
			if( abs(vA-vB) <= 6.0/255.0) {
				similar=true;
			}
		}
	}
	return similar;
}

/**
* @fn vec4 evaluatePixel(vec2 evalPos)
* Computes the E value to be written to the current fragment.
* @param evalPos Fragment position relative to evaluation window: <BR> UL UR <BR> LL LR
* @return evaluated edge value (see defined macros linked below)
* @see EDGE_HORVERT
* @see EDGE_DIAGONAL_ULLR
* @see EDGE_DIAGONAL_LLUR
* @see EDGE_CROSSING
*/
vec4 evaluatePixel(vec2 evalPos) {

	vec4 value = vec4(0.0 , 0.0 , 0.0 , 0.0);
	//if the current fragment represents a node invalidate it by setting it to zero
	if ( evalPos == vec2(1,1) ) {
		//value = vec4(0.0 , 0.0 , 0.0 , 0.0);
		ivec2 pCoord = getPixelCoords(ivec2(gl_FragCoord.xy));
		value = texelFetch(pixelArt, pCoord,0);
	} else if (evalPos == vec2(0,0)){
		//UL ... diagonal
		int diagonal = 0;
		//check UL-LR connection
		ivec2 pACoord = getPixelCoords(ivec2(gl_FragCoord.x-1,gl_FragCoord.y+1));
		vec4 pA = texelFetch(pixelArt, pACoord ,0);
		ivec2 pBCoord = getPixelCoords(ivec2(gl_FragCoord.x+1,gl_FragCoord.y-1));
		vec4 pB = texelFetch(pixelArt, pBCoord ,0);
		if (isSimilar(pA,pB)) {
			diagonal = EDGE_DIAGONAL_ULLR;
		}
		//check LL-UR connection
		pACoord = getPixelCoords(ivec2(gl_FragCoord.x-1,gl_FragCoord.y-1));
		pA = texelFetch(pixelArt, pACoord ,0);
		pBCoord = getPixelCoords(ivec2(gl_FragCoord.x+1,gl_FragCoord.y+1));
		pB = texelFetch(pixelArt, pBCoord ,0);
		if (isSimilar(pA,pB)) {
			diagonal = diagonal | EDGE_DIAGONAL_LLUR;
		}
		
		value = vec4(diagonal/255.0, 0.0 , 0.0 , 0.0);
	} else if (evalPos == vec2(0,1)){
		//LL ... horizontal Edge
		//pA, pB ... pixels connected by edge
		ivec2 pACoord = getPixelCoords(ivec2(gl_FragCoord.x-1,gl_FragCoord.y));
		vec4 pA = texelFetch(pixelArt, pACoord ,0);
		ivec2 pBCoord = getPixelCoords(ivec2(gl_FragCoord.x+1,gl_FragCoord.y));
		vec4 pB = texelFetch(pixelArt, pBCoord ,0);
		if (isSimilar(pA,pB)) {
			value = vec4(16.0/255.0 , 0.0 , 0.0 , 0.0);
		}
	} else if (evalPos == vec2(1,0)){
		//UR ... vertical edge
		//pA, pB ... pixels connected by edge
		ivec2 pACoord = getPixelCoords(ivec2(gl_FragCoord.x,gl_FragCoord.y-1));
		vec4 pA = texelFetch(pixelArt, pACoord ,0);
		ivec2 pBCoord = getPixelCoords(ivec2(gl_FragCoord.x,gl_FragCoord.y+1));
		vec4 pB = texelFetch(pixelArt, pBCoord ,0);
		if (isSimilar(pA,pB)) {
			value = vec4(16.0/255.0 , 0.0 , 0.0 , 0.0);
		}
	} 
	return value;
}

/**
* @fn void main()
* main function.
* responsible for border control (E values for borders will be set to 0).
* computes position in evaluation window and calls evaluatePixel.
*/
void main() {

	//evalPos evaluation window position
	// UL UR
	// LL LR
	ivec2 samplerDimensions = textureSize(pixelArt, 0);
	if( gl_FragCoord.x==0 || gl_FragCoord.x==2*samplerDimensions.x || gl_FragCoord.y==0 || gl_FragCoord.y==2*samplerDimensions.y ) {
		//border hit
		color0 = vec4(0.0 , 0.0 , 0.0 , 0.0);
	} else {
		vec2 evalPos = mod(gl_FragCoord.xy,2);
		color0 = evaluatePixel(evalPos);
	}
}
